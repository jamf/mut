//
//  tokenManagement.swift
//  The MUT v5
//
//  Created by Michael Levenick on 5/24/19.
//  Copyright Â© 2019 Levenick Enterprises, LLC. All rights reserved.
//

import Foundation
import SwiftyJSON

public class tokenManagement: NSObject {
    
    let logMan = logManager()
    let sessionHandler = SessionHandler.SharedSessionHandler
    let tokenDefaults = UserDefaults.standard

    
    // This function can be used to generate a token using OAuth client credentials.
    public func getToken(allowUntrusted: Bool){
        let dataPrep = dataPreparation()

        // Create OAuth token URL using the existing URL builder
        // OAuth endpoint is /api/oauth/token (no version number)
        let tokenURL = dataPrep.generateJpapiURL(endpoint: "oauth/token", endpointVersion: "", identifier: "")
        
        // The semaphore is what allows us to force the code to wait for this request to complete
        // Without the semaphore, MUT will queue up a request for every single line of the CSV simultaneously
        let semaphore = DispatchSemaphore(value: 0)
        let request = NSMutableURLRequest(url: tokenURL)

        // OAuth uses POST with form-encoded data
        request.httpMethod = "POST"
        
        // Set content type for form data
        request.addValue("application/x-www-form-urlencoded", forHTTPHeaderField: "Content-Type")
        
        // Build form data with client credentials
        // URL encode the client_id and client_secret to handle special characters
        guard let clientId = Credentials.clientId?.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed),
              let clientSecret = Credentials.clientSecret?.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) else {
            self.logMan.writeLog(level: .error, logString: "Failed to encode client credentials")
            return
        }
        
        let bodyString = "client_id=\(clientId)&client_secret=\(clientSecret)&grant_type=client_credentials"
        request.httpBody = bodyString.data(using: .utf8)
        
        // set session to use
        let session = sessionHandler.mySession
        sessionHandler.setAllowUntrusted(allowUntrusted: allowUntrusted)
        
        // Completion handler. This is what ensures that the response is good/bad
        // and also what handles the semaphore
        let task = session.dataTask(with: request as URLRequest, completionHandler: {
            (data, response, error) -> Void in
            if let httpResponse = response as? HTTPURLResponse {
                if httpResponse.statusCode >= 199 && httpResponse.statusCode <= 299 {
                    // Good response from API
                    Token.data = data!
                    self.logMan.writeLog(level: .info, logString: "A new token was successfully generated by MUT.  \(httpResponse.statusCode).")
                } else {
                    // Bad Response from API
                    Token.data = data!
                    self.logMan.writeLog(level: .error, logString: "MUT Failed to generate a token.  \(httpResponse.statusCode).")
                    self.logMan.writeLog(level: .error, logString: String(decoding: Token.data!, as: UTF8.self))
                }
                semaphore.signal() // Signal completion to the semaphore
            }
            
            if error != nil {
                let errorString = "[FATAL ]: " + error!.localizedDescription
                Token.data = errorString.data(using: .utf8)!
                self.logMan.writeLog(level: .fatal, logString: error!.localizedDescription)
                semaphore.signal() // Signal completion to the semaphore
            }
        })
        task.resume() // Kick off the actual POST here
        semaphore.wait() // Wait for the semaphore before moving on to the return value
        
        if String(decoding: Token.data!, as: UTF8.self).contains("FATAL") {
            _ = popPrompt().fatalWarning(error: String(decoding: Token.data!, as: UTF8.self))
        } else {
            // No error found leads you here:
            if String(decoding: Token.data!, as: UTF8.self).contains("access_token") {
                // Good credentials here, as told by there being an access_token
                do {
                    // Parse the JSON to return token and Expiry
                    let newJson = try JSON(data: Token.data!)
                    Token.value = newJson["access_token"].stringValue
                    
                    // OAuth returns expires_in as seconds from now, not an absolute timestamp
                    let expiresIn = newJson["expires_in"].intValue
                    // Calculate absolute expiration time in milliseconds
                    let currentTime = Int(Date().timeIntervalSince1970 * 1000)
                    Token.expiration = currentTime + (expiresIn * 1000)
                    
                    self.logMan.writeLog(level: .info, logString: "Token will expire in \(expiresIn) seconds.")
                    
                } catch let error as NSError {
                    self.logMan.writeLog(level: .error, logString: "Failed to load: \(error.localizedDescription)")
                }
            }
        }
    }
    
    public func tokenRefresher() {
        let currentEpoch = Int(Date().timeIntervalSince1970 * 1000)
        
        // Find the difference between expiry time and current epoch
        let secondsToExpire = (Token.expiration! - currentEpoch)/1000
        
        if secondsToExpire <= 30 {
            logMan.writeLog(level: .info, logString: "Token only has \(secondsToExpire) seconds left to live. Refreshing token.")
            getToken(allowUntrusted: self.tokenDefaults.bool(forKey: "Insecure"))
        } else {
            logMan.writeLog(level: .info, logString: "Token has \(secondsToExpire) seconds left to live. Proceeding with current token.")
        }
    }
}
